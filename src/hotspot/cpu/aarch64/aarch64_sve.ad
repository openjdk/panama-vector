//
// Copyright (c) 2020, 2021, Oracle and/or its affiliates. All rights reserved.
// Copyright (c) 2020, 2021, Arm Limited. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//

// This file is automatically generated by running "m4 aarch64_sve_ad.m4". Do not edit ----

// AArch64 SVE Architecture Description File


// 4 bit signed offset -- for predicated load/store

operand vmemA_immIOffset4()
%{
  // (esize / msize) = 1
  predicate(Address::offset_ok_for_sve_immed(n->get_int(), 4,
            Matcher::scalable_vector_reg_size(T_BYTE)));
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand vmemA_immLOffset4()
%{
  // (esize / msize) = 1
  predicate(Address::offset_ok_for_sve_immed(n->get_long(), 4,
            Matcher::scalable_vector_reg_size(T_BYTE)));
  match(ConL);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand vmemA_indOffI4(iRegP reg, vmemA_immIOffset4 off)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP reg off);
  op_cost(0);
  format %{ "[$reg, $off]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0xffffffff);
    scale(0x0);
    disp($off);
  %}
%}

operand vmemA_indOffL4(iRegP reg, vmemA_immLOffset4 off)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP reg off);
  op_cost(0);
  format %{ "[$reg, $off]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0xffffffff);
    scale(0x0);
    disp($off);
  %}
%}

// The indOff of vmemA is valid only when the vector element (load to/store from)
// size equals to memory element (load from/store to) size.
opclass vmemA(indirect, vmemA_indOffI4, vmemA_indOffL4);

source_hpp %{
  bool op_sve_supported(int opcode, int vlen, BasicType bt);
%}

source %{
  static inline BasicType vector_element_basic_type(const MachNode* n) {
    const TypeVect* vt = n->bottom_type()->is_vect();
    return vt->element_basic_type();
  }

  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {
    int def_idx = use->operand_index(opnd);
    Node* def = use->in(def_idx);
    const TypeVect* vt = def->bottom_type()->is_vect();
    return vt->element_basic_type();
  }

  static inline uint vector_length(const MachNode* n) {
    const TypeVect* vt = n->bottom_type()->is_vect();
    return vt->length();
  }

  static inline uint vector_length(const MachNode* use, const MachOper* opnd) {
    int def_idx = use->operand_index(opnd);
    Node* def = use->in(def_idx);
    const TypeVect* vt = def->bottom_type()->is_vect();
    return vt->length();
  }

  static inline uint vector_length_in_bytes(const MachNode* n) {
    const TypeVect* vt = n->bottom_type()->is_vect();
    return vt->length_in_bytes();
  }

  static inline uint vector_length_in_bytes(const MachNode* use, MachOper* opnd) {
    uint def_idx = use->operand_index(opnd);
    Node* def = use->in(def_idx);
    const TypeVect* vt = def->bottom_type()->is_vect();
    return vt->length_in_bytes();
  }

  static Assembler::SIMD_RegVariant elemBytes_to_regVariant(int esize) {
    switch(esize) {
      case 1:
        return Assembler::B;
      case 2:
        return Assembler::H;
      case 4:
        return Assembler::S;
      case 8:
        return Assembler::D;
      default:
        assert(false, "unsupported");
        ShouldNotReachHere();
    }
    return Assembler::INVALID;
  }

  static Assembler::SIMD_RegVariant elemType_to_regVariant(BasicType bt) {
    return elemBytes_to_regVariant(type2aelembytes(bt));
  }

  typedef void (C2_MacroAssembler::* sve_mem_insn_predicate)(FloatRegister Rt, Assembler::SIMD_RegVariant T,
                                                             PRegister Pg, const Address &adr);

  // Predicated load/store, with optional ptrue to all elements of given predicate register.
  static void loadStoreA_predicate(C2_MacroAssembler masm, bool is_store, FloatRegister reg,
                                   PRegister pg, BasicType mem_elem_bt, BasicType vector_elem_bt,
                                   int opcode, Register base, int index, int size, int disp) {
    sve_mem_insn_predicate insn;
    int mesize = type2aelembytes(mem_elem_bt);
    if (index == -1) {
      assert(size == 0, "unsupported address mode: scale size = %d", size);
      switch(mesize) {
      case 1:
        insn = is_store ? &C2_MacroAssembler::sve_st1b : &C2_MacroAssembler::sve_ld1b;
        break;
      case 2:
        insn = is_store ? &C2_MacroAssembler::sve_st1h : &C2_MacroAssembler::sve_ld1h;
        break;
      case 4:
        insn = is_store ? &C2_MacroAssembler::sve_st1w : &C2_MacroAssembler::sve_ld1w;
        break;
      case 8:
        insn = is_store ? &C2_MacroAssembler::sve_st1d : &C2_MacroAssembler::sve_ld1d;
        break;
      default:
        assert(false, "unsupported");
        ShouldNotReachHere();
      }
      int imm4 = disp / mesize / Matcher::scalable_vector_reg_size(vector_elem_bt);
      (masm.*insn)(reg, elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));
    } else {
      assert(false, "unimplemented");
      ShouldNotReachHere();
    }
  }

  static void sve_compare(C2_MacroAssembler masm, PRegister pd, BasicType bt,
                          PRegister pg, FloatRegister zn, FloatRegister zm, int cond) {
    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);
    if (bt == T_FLOAT || bt == T_DOUBLE) {
      switch (cond) {
        case BoolTest::eq: masm.sve_fcmeq(pd, size, pg, zn, zm); break;
        case BoolTest::ne: masm.sve_fcmne(pd, size, pg, zn, zm); break;
        case BoolTest::ge: masm.sve_fcmge(pd, size, pg, zn, zm); break;
        case BoolTest::gt: masm.sve_fcmgt(pd, size, pg, zn, zm); break;
        case BoolTest::le: masm.sve_fcmge(pd, size, pg, zm, zn); break;
        case BoolTest::lt: masm.sve_fcmgt(pd, size, pg, zm, zn); break;
        default:
          assert(false, "unsupported");
          ShouldNotReachHere();
      }
    } else {
      switch (cond) {
        case BoolTest::eq: masm.sve_cmpeq(pd, size, pg, zn, zm); break;
        case BoolTest::ne: masm.sve_cmpne(pd, size, pg, zn, zm); break;
        case BoolTest::ge: masm.sve_cmpge(pd, size, pg, zn, zm); break;
        case BoolTest::gt: masm.sve_cmpgt(pd, size, pg, zn, zm); break;
        case BoolTest::le: masm.sve_cmpge(pd, size, pg, zm, zn); break;
        case BoolTest::lt: masm.sve_cmpgt(pd, size, pg, zm, zn); break;
        default:
          assert(false, "unsupported");
          ShouldNotReachHere();
      }
    }
  }

  bool op_sve_supported(int opcode, int vlen, BasicType bt) {
    switch (opcode) {
      case Op_MulAddVS2VI:
        // No multiply reduction instructions
      case Op_MulReductionVD:
      case Op_MulReductionVF:
      case Op_MulReductionVI:
      case Op_MulReductionVL:
        // Others
      case Op_ExtractC:
      case Op_ExtractUB:
      // Vector API specific
      case Op_VectorLoadConst:
        return false;
      case Op_VectorLoadShuffle:
      case Op_VectorRearrange:
        if (vlen < 4) {
          return false;
        }
        break;
      default:
        break;
    }
    // By default, we only support vector operations with larger than 16 bytes.
    int length_in_bytes = vlen * type2aelembytes(bt);
    return 16 <= length_in_bytes && length_in_bytes <= MaxVectorSize;
  }
%}

definitions %{
  int_def SVE_COST             (200, 200);
%}


// All SVE instructions

// vector load/store

// Unpredicated vector load/store
instruct loadV(vReg dst, vmemA mem) %{
  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() >= 16 &&
            n->as_LoadVector()->memory_size() == MaxVectorSize);
  match(Set dst (LoadVector mem));
  ins_cost(4 * SVE_COST);
  format %{ "sve_ldr $dst, $mem\t # vector (sve)" %}
  ins_encode %{
    FloatRegister dst_reg = as_FloatRegister($dst$$reg);
    BasicType bt = vector_element_basic_type(this);
    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,
                         bt, bt, $mem->opcode(),
                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
  %}
  ins_pipe(pipe_slow);
%}

instruct storeV(vReg src, vmemA mem) %{
  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() >= 16 &&
            n->as_StoreVector()->memory_size() == MaxVectorSize);
  match(Set mem (StoreVector mem src));
  ins_cost(4 * SVE_COST);
  format %{ "sve_str $mem, $src\t # vector (sve)" %}
  ins_encode %{
    FloatRegister src_reg = as_FloatRegister($src$$reg);
    BasicType bt = vector_element_basic_type(this, $src);
    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, src_reg, ptrue,
                         bt, bt, $mem->opcode(),
                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
  %}
  ins_pipe(pipe_slow);
%}

// Load Vector (16 bits)
instruct loadV2_vreg(vReg dst, vmem2 mem)
%{
  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 2 &&
            n->as_LoadVector()->memory_size() < MaxVectorSize);
  match(Set dst (LoadVector mem));
  ins_cost(4 * SVE_COST);
  format %{ "ldrh   $dst,$mem\t# vector (16 bits)" %}
  ins_encode( aarch64_enc_ldrvH(dst, mem) );
  ins_pipe(vload_reg_mem64);
%}

// Store Vector (16 bits)
instruct storeV2_vreg(vReg src, vmem2 mem)
%{
  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 2 &&
            n->as_StoreVector()->memory_size() < MaxVectorSize);
  match(Set mem (StoreVector mem src));
  ins_cost(4 * SVE_COST);
  format %{ "strh   $mem,$src\t# vector (16 bits)" %}
  ins_encode( aarch64_enc_strvH(src, mem) );
  ins_pipe(vstore_reg_mem64);
%}

// Load Vector (32 bits)
instruct loadV4_vreg(vReg dst, vmem4 mem)
%{
  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 4 &&
            n->as_LoadVector()->memory_size() < MaxVectorSize);
  match(Set dst (LoadVector mem));
  ins_cost(4 * SVE_COST);
  format %{ "ldrs   $dst,$mem\t# vector (32 bits)" %}
  ins_encode( aarch64_enc_ldrvS(dst, mem) );
  ins_pipe(vload_reg_mem64);
%}

// Store Vector (32 bits)
instruct storeV4_vreg(vReg src, vmem4 mem)
%{
  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 4 &&
            n->as_StoreVector()->memory_size() < MaxVectorSize);
  match(Set mem (StoreVector mem src));
  ins_cost(4 * SVE_COST);
  format %{ "strs   $mem,$src\t# vector (32 bits)" %}
  ins_encode( aarch64_enc_strvS(src, mem) );
  ins_pipe(vstore_reg_mem64);
%}

// Load Vector (64 bits)
instruct loadV8_vreg(vReg dst, vmem8 mem)
%{
  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 8 &&
            n->as_LoadVector()->memory_size() < MaxVectorSize);
  match(Set dst (LoadVector mem));
  ins_cost(4 * SVE_COST);
  format %{ "ldrd   $dst,$mem\t# vector (64 bits)" %}
  ins_encode( aarch64_enc_ldrvD(dst, mem) );
  ins_pipe(vload_reg_mem64);
%}

// Store Vector (64 bits)
instruct storeV8_vreg(vReg src, vmem8 mem)
%{
  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 8 &&
            n->as_StoreVector()->memory_size() < MaxVectorSize);
  match(Set mem (StoreVector mem src));
  ins_cost(4 * SVE_COST);
  format %{ "strd   $mem,$src\t# vector (64 bits)" %}
  ins_encode( aarch64_enc_strvD(src, mem) );
  ins_pipe(vstore_reg_mem64);
%}

// Load Vector (128 bits)
instruct loadV16_vreg(vReg dst, vmem16 mem)
%{
  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() == 16 &&
            n->as_LoadVector()->memory_size() < MaxVectorSize);
  match(Set dst (LoadVector mem));
  ins_cost(4 * SVE_COST);
  format %{ "ldrq   $dst,$mem\t# vector (128 bits)" %}
  ins_encode( aarch64_enc_ldrvQ(dst, mem) );
  ins_pipe(vload_reg_mem128);
%}

// Store Vector (128 bits)
instruct storeV16_vreg(vReg src, vmem16 mem)
%{
  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() == 16 &&
            n->as_StoreVector()->memory_size() < MaxVectorSize);
  match(Set mem (StoreVector mem src));
  ins_cost(4 * SVE_COST);
  format %{ "strq   $mem,$src\t# vector (128 bits)" %}
  ins_encode( aarch64_enc_strvQ(src, mem) );
  ins_pipe(vstore_reg_mem128);
%}

// Predicated vector load/store, based on the vector length of the node.
// Only load/store values in the range of the memory_size. This is needed
// when the memory_size is lower than the hardware supported max vector size.
// And this might happen for Vector API mask vector load/store.
instruct loadV_partial(vReg dst, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->as_LoadVector()->memory_size() > 16 &&
            n->as_LoadVector()->memory_size() < MaxVectorSize);
  match(Set dst (LoadVector mem));
  effect(TEMP pTmp, KILL cr);
  ins_cost(6 * SVE_COST);
  format %{ "mov rscratch1, vector_length\n\t"
            "sve_whilelo $pTmp, zr, rscratch1\n\t"
            "sve_ldr $dst, $pTmp, $mem\t # load vector mask (sve)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this);
    __ mov(rscratch1, vector_length(this));
    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);
    __ sve_whilelo(as_PRegister($pTmp$$reg), size, zr, rscratch1);
    FloatRegister dst_reg = as_FloatRegister($dst$$reg);
    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg,
                         as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),
                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
  %}
  ins_pipe(pipe_slow);
%}

instruct storeV_partial(vReg src, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() > 16 &&
            n->as_StoreVector()->memory_size() < MaxVectorSize);
  match(Set mem (StoreVector mem src));
  effect(TEMP pTmp, KILL cr);
  ins_cost(5 * SVE_COST);
  format %{ "mov rscratch1, vector_length\n\t"
            "sve_whilelo $pTmp, zr, rscratch1\n\t"
            "sve_str $src, $pTmp, $mem\t # store vector mask (sve)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this, $src);
    __ mov(rscratch1, vector_length(this, $src));
    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);
    __ sve_whilelo(as_PRegister($pTmp$$reg), size, zr, rscratch1);
    FloatRegister src_reg = as_FloatRegister($src$$reg);
    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, src_reg,
                         as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),
                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
  %}
  ins_pipe(pipe_slow);
%}

// vector reinterpret

instruct reinterpret(vReg dst) %{
  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() ==
                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  // src == dst
  match(Set dst (VectorReinterpret dst));
  ins_cost(0);
  format %{ "# reinterpret $dst\t# do nothing" %}
  ins_encode %{
    // empty
  %}
  ins_pipe(pipe_class_empty);
%}

instruct reinterpretResize(vReg dst, vReg src, pRegGov pTmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() !=
                          n->in(1)->bottom_type()->is_vect()->length_in_bytes());  // src != dst
  match(Set dst (VectorReinterpret src));
  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);
  ins_cost(3 * SVE_COST);
  format %{ "reinterpretResize $dst, $src\t# vector (sve)" %}
  ins_encode %{
    uint length_in_bytes_src = vector_length_in_bytes(this, $src);
    uint length_in_bytes_dst = vector_length_in_bytes(this);
    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?
                                  length_in_bytes_src : length_in_bytes_dst;
    assert(length_in_bytes_src <= MaxVectorSize && length_in_bytes_dst <= MaxVectorSize,
           "invalid vector length");
    __ mov(rscratch1, length_in_bytes_resize);
    __ sve_whilelo(as_PRegister($pTmp$$reg), __ B, zr, rscratch1);
    __ sve_dup(as_FloatRegister($dst$$reg), __ B, 0);
    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pTmp$$reg),
               as_FloatRegister($src$$reg), as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}
// vector abs

instruct vabsB(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (AbsVB src));
  ins_cost(SVE_COST);
  format %{ "sve_abs $dst, $src\t# vector (sve) (B)" %}
  ins_encode %{
    __ sve_abs(as_FloatRegister($dst$$reg), __ B,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vabsS(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (AbsVS src));
  ins_cost(SVE_COST);
  format %{ "sve_abs $dst, $src\t# vector (sve) (H)" %}
  ins_encode %{
    __ sve_abs(as_FloatRegister($dst$$reg), __ H,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vabsI(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_INT);
  match(Set dst (AbsVI src));
  ins_cost(SVE_COST);
  format %{ "sve_abs $dst, $src\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_abs(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vabsL(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (AbsVL src));
  ins_cost(SVE_COST);
  format %{ "sve_abs $dst, $src\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_abs(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vabsF(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
  match(Set dst (AbsVF src));
  ins_cost(SVE_COST);
  format %{ "sve_fabs $dst, $src\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_fabs(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vabsD(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
  match(Set dst (AbsVD src));
  ins_cost(SVE_COST);
  format %{ "sve_fabs $dst, $src\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_fabs(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector add

instruct vaddB(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (AddVB src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_add $dst, $src1, $src2\t # vector (sve) (B)" %}
  ins_encode %{
    __ sve_add(as_FloatRegister($dst$$reg), __ B,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vaddS(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (AddVS src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_add $dst, $src1, $src2\t # vector (sve) (H)" %}
  ins_encode %{
    __ sve_add(as_FloatRegister($dst$$reg), __ H,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vaddI(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (AddVI src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_add $dst, $src1, $src2\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_add(as_FloatRegister($dst$$reg), __ S,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vaddL(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (AddVL src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_add $dst, $src1, $src2\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_add(as_FloatRegister($dst$$reg), __ D,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vaddF(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (AddVF src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_fadd $dst, $src1, $src2\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_fadd(as_FloatRegister($dst$$reg), __ S,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vaddD(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (AddVD src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_fadd $dst, $src1, $src2\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_fadd(as_FloatRegister($dst$$reg), __ D,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector and

instruct vand(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (AndV src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_and  $dst, $src1, $src2\t# vector (sve)" %}
  ins_encode %{
    __ sve_and(as_FloatRegister($dst$$reg),
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector or

instruct vor(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (OrV src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_orr  $dst, $src1, $src2\t# vector (sve)" %}
  ins_encode %{
    __ sve_orr(as_FloatRegister($dst$$reg),
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector xor

instruct vxor(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (XorV src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_eor  $dst, $src1, $src2\t# vector (sve)" %}
  ins_encode %{
    __ sve_eor(as_FloatRegister($dst$$reg),
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector float div

instruct vdivF(vReg dst_src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst_src1 (DivVF dst_src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_fdiv  $dst_src1, $dst_src1, $src2\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vdivD(vReg dst_src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst_src1 (DivVD dst_src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_fdiv  $dst_src1, $dst_src1, $src2\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_fdiv(as_FloatRegister($dst_src1$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector min/max

instruct vmin(vReg dst_src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst_src1 (MinV dst_src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_min $dst_src1, $dst_src1, $src2\t # vector (sve)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);
    if (is_floating_point_type(bt)) {
      __ sve_fmin(as_FloatRegister($dst_src1$$reg), size,
                  ptrue, as_FloatRegister($src2$$reg));
    } else {
      assert(is_integral_type(bt), "Unsupported type");
      __ sve_smin(as_FloatRegister($dst_src1$$reg), size,
                  ptrue, as_FloatRegister($src2$$reg));
    }
  %}
  ins_pipe(pipe_slow);
%}

instruct vmax(vReg dst_src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst_src1 (MaxV dst_src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_max $dst_src1, $dst_src1, $src2\t # vector (sve)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this);
    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);
    if (is_floating_point_type(bt)) {
      __ sve_fmax(as_FloatRegister($dst_src1$$reg), size,
                  ptrue, as_FloatRegister($src2$$reg));
    } else {
      assert(is_integral_type(bt), "Unsupported type");
      __ sve_smax(as_FloatRegister($dst_src1$$reg), size,
                  ptrue, as_FloatRegister($src2$$reg));
    }
  %}
  ins_pipe(pipe_slow);
%}

// vector fmla

// dst_src1 = dst_src1 + src2 * src3
instruct vfmlaF(vReg dst_src1, vReg src2, vReg src3) %{
  predicate(UseFMA && UseSVE > 0);
  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_fmla $dst_src1, $src2, $src3\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = dst_src1 + src2 * src3
instruct vfmlaD(vReg dst_src1, vReg src2, vReg src3) %{
  predicate(UseFMA && UseSVE > 0);
  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_fmla $dst_src1, $src2, $src3\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_fmla(as_FloatRegister($dst_src1$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector fmls

// dst_src1 = dst_src1 + -src2 * src3
// dst_src1 = dst_src1 + src2 * -src3
instruct vfmlsF(vReg dst_src1, vReg src2, vReg src3) %{
  predicate(UseFMA && UseSVE > 0);
  match(Set dst_src1 (FmaVF dst_src1 (Binary (NegVF src2) src3)));
  match(Set dst_src1 (FmaVF dst_src1 (Binary src2 (NegVF src3))));
  ins_cost(SVE_COST);
  format %{ "sve_fmls $dst_src1, $src2, $src3\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = dst_src1 + -src2 * src3
// dst_src1 = dst_src1 + src2 * -src3
instruct vfmlsD(vReg dst_src1, vReg src2, vReg src3) %{
  predicate(UseFMA && UseSVE > 0);
  match(Set dst_src1 (FmaVD dst_src1 (Binary (NegVD src2) src3)));
  match(Set dst_src1 (FmaVD dst_src1 (Binary src2 (NegVD src3))));
  ins_cost(SVE_COST);
  format %{ "sve_fmls $dst_src1, $src2, $src3\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_fmls(as_FloatRegister($dst_src1$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector fnmla

// dst_src1 = -dst_src1 + -src2 * src3
// dst_src1 = -dst_src1 + src2 * -src3
instruct vfnmlaF(vReg dst_src1, vReg src2, vReg src3) %{
  predicate(UseFMA && UseSVE > 0);
  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary (NegVF src2) src3)));
  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 (NegVF src3))));
  ins_cost(SVE_COST);
  format %{ "sve_fnmla $dst_src1, $src2, $src3\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = -dst_src1 + -src2 * src3
// dst_src1 = -dst_src1 + src2 * -src3
instruct vfnmlaD(vReg dst_src1, vReg src2, vReg src3) %{
  predicate(UseFMA && UseSVE > 0);
  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary (NegVD src2) src3)));
  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 (NegVD src3))));
  ins_cost(SVE_COST);
  format %{ "sve_fnmla $dst_src1, $src2, $src3\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_fnmla(as_FloatRegister($dst_src1$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector fnmls

// dst_src1 = -dst_src1 + src2 * src3
instruct vfnmlsF(vReg dst_src1, vReg src2, vReg src3) %{
  predicate(UseFMA && UseSVE > 0);
  match(Set dst_src1 (FmaVF (NegVF dst_src1) (Binary src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_fnmls $dst_src1, $src2, $src3\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = -dst_src1 + src2 * src3
instruct vfnmlsD(vReg dst_src1, vReg src2, vReg src3) %{
  predicate(UseFMA && UseSVE > 0);
  match(Set dst_src1 (FmaVD (NegVD dst_src1) (Binary src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_fnmls $dst_src1, $src2, $src3\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_fnmls(as_FloatRegister($dst_src1$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector mla

// dst_src1 = dst_src1 + src2 * src3
instruct vmlaB(vReg dst_src1, vReg src2, vReg src3)
%{
  predicate(UseSVE > 0);
  match(Set dst_src1 (AddVB dst_src1 (MulVB src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_mla $dst_src1, src2, src3\t # vector (sve) (B)" %}
  ins_encode %{
    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ B,
      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = dst_src1 + src2 * src3
instruct vmlaS(vReg dst_src1, vReg src2, vReg src3)
%{
  predicate(UseSVE > 0);
  match(Set dst_src1 (AddVS dst_src1 (MulVS src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_mla $dst_src1, src2, src3\t # vector (sve) (H)" %}
  ins_encode %{
    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ H,
      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = dst_src1 + src2 * src3
instruct vmlaI(vReg dst_src1, vReg src2, vReg src3)
%{
  predicate(UseSVE > 0);
  match(Set dst_src1 (AddVI dst_src1 (MulVI src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_mla $dst_src1, src2, src3\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ S,
      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = dst_src1 + src2 * src3
instruct vmlaL(vReg dst_src1, vReg src2, vReg src3)
%{
  predicate(UseSVE > 0);
  match(Set dst_src1 (AddVL dst_src1 (MulVL src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_mla $dst_src1, src2, src3\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_mla(as_FloatRegister($dst_src1$$reg), __ D,
      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector mls

// dst_src1 = dst_src1 - src2 * src3
instruct vmlsB(vReg dst_src1, vReg src2, vReg src3)
%{
  predicate(UseSVE > 0);
  match(Set dst_src1 (SubVB dst_src1 (MulVB src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_mls $dst_src1, src2, src3\t # vector (sve) (B)" %}
  ins_encode %{
    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ B,
      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = dst_src1 - src2 * src3
instruct vmlsS(vReg dst_src1, vReg src2, vReg src3)
%{
  predicate(UseSVE > 0);
  match(Set dst_src1 (SubVS dst_src1 (MulVS src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_mls $dst_src1, src2, src3\t # vector (sve) (H)" %}
  ins_encode %{
    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ H,
      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = dst_src1 - src2 * src3
instruct vmlsI(vReg dst_src1, vReg src2, vReg src3)
%{
  predicate(UseSVE > 0);
  match(Set dst_src1 (SubVI dst_src1 (MulVI src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_mls $dst_src1, src2, src3\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ S,
      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// dst_src1 = dst_src1 - src2 * src3
instruct vmlsL(vReg dst_src1, vReg src2, vReg src3)
%{
  predicate(UseSVE > 0);
  match(Set dst_src1 (SubVL dst_src1 (MulVL src2 src3)));
  ins_cost(SVE_COST);
  format %{ "sve_mls $dst_src1, src2, src3\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_mls(as_FloatRegister($dst_src1$$reg), __ D,
      ptrue, as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}
  ins_pipe(pipe_slow);
%}


// vector mul

instruct vmulB(vReg dst_src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst_src1 (MulVB dst_src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_mul $dst_src1, $dst_src1, $src2\t # vector (sve) (B)" %}
  ins_encode %{
    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ B,
         ptrue, as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vmulS(vReg dst_src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst_src1 (MulVS dst_src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_mul $dst_src1, $dst_src1, $src2\t # vector (sve) (H)" %}
  ins_encode %{
    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ H,
         ptrue, as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vmulI(vReg dst_src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst_src1 (MulVI dst_src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_mul $dst_src1, $dst_src1, $src2\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vmulL(vReg dst_src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst_src1 (MulVL dst_src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_mul $dst_src1, $dst_src1, $src2\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_mul(as_FloatRegister($dst_src1$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vmulF(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (MulVF src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_fmul $dst, $src1, $src2\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_fmul(as_FloatRegister($dst$$reg), __ S,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vmulD(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (MulVD src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_fmul $dst, $src1, $src2\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_fmul(as_FloatRegister($dst$$reg), __ D,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector fneg

instruct vnegF(vReg dst, vReg src) %{
  predicate(UseSVE > 0);
  match(Set dst (NegVF src));
  ins_cost(SVE_COST);
  format %{ "sve_fneg $dst, $src\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_fneg(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vnegD(vReg dst, vReg src) %{
  predicate(UseSVE > 0);
  match(Set dst (NegVD src));
  ins_cost(SVE_COST);
  format %{ "sve_fneg $dst, $src\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_fneg(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// popcount vector

instruct vpopcountI(vReg dst, vReg src) %{
  predicate(UseSVE > 0);
  match(Set dst (PopCountVI src));
  format %{ "sve_cnt $dst, $src\t# vector (sve) (S)\n\t" %}
  ins_encode %{
     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector mask compare

instruct vmaskcmp(vReg dst, vReg src1, vReg src2, immI cond, pRegGov pTmp, rFlagsReg cr) %{
  predicate(UseSVE > 0);
  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));
  effect(TEMP pTmp, KILL cr);
  ins_cost(2 * SVE_COST);
  format %{ "sve_cmp $pTmp, $src1, $src2\n\t"
            "sve_cpy $dst, $pTmp, -1\t # vector mask cmp (sve)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this);
    sve_compare(C2_MacroAssembler(&cbuf), as_PRegister($pTmp$$reg), bt,
                ptrue, as_FloatRegister($src1$$reg),
                as_FloatRegister($src2$$reg), (int)$cond$$constant);
    __ sve_cpy(as_FloatRegister($dst$$reg), elemType_to_regVariant(bt),
               as_PRegister($pTmp$$reg), -1, false);
  %}
  ins_pipe(pipe_slow);
%}

// vector blend

instruct vblend(vReg dst, vReg src1, vReg src2, vReg src3, pRegGov pTmp, rFlagsReg cr) %{
  predicate(UseSVE > 0);
  match(Set dst (VectorBlend (Binary src1 src2) src3));
  effect(TEMP pTmp, KILL cr);
  ins_cost(2 * SVE_COST);
  format %{ "sve_cmpeq $pTmp, $src3, -1\n\t"
            "sve_sel $dst, $pTmp, $src2, $src1\t # vector blend (sve)" %}
  ins_encode %{
    Assembler::SIMD_RegVariant size =
              elemType_to_regVariant(vector_element_basic_type(this));
    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,
                 as_FloatRegister($src3$$reg), -1);
    __ sve_sel(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg),
               as_FloatRegister($src2$$reg), as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector blend with compare

instruct vblend_maskcmp(vReg dst, vReg src1, vReg src2, vReg src3,
                        vReg src4, pRegGov pTmp, immI cond, rFlagsReg cr) %{
  predicate(UseSVE > 0);
  match(Set dst (VectorBlend (Binary src1 src2) (VectorMaskCmp (Binary src3 src4) cond)));
  effect(TEMP pTmp, KILL cr);
  ins_cost(2 * SVE_COST);
  format %{ "sve_cmp $pTmp, $src3, $src4\t # vector cmp (sve)\n\t"
            "sve_sel $dst, $pTmp, $src2, $src1\t # vector blend (sve)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this);
    sve_compare(C2_MacroAssembler(&cbuf), as_PRegister($pTmp$$reg), bt,
                ptrue, as_FloatRegister($src3$$reg),
                as_FloatRegister($src4$$reg), (int)$cond$$constant);
    __ sve_sel(as_FloatRegister($dst$$reg), elemType_to_regVariant(bt),
               as_PRegister($pTmp$$reg), as_FloatRegister($src2$$reg),
               as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector load mask

instruct vloadmaskB(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorLoadMask src));
  ins_cost(SVE_COST);
  format %{ "sve_neg $dst, $src\t # vector load mask (B)" %}
  ins_encode %{
    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,
               as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vloadmaskS(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorLoadMask src));
  ins_cost(2 * SVE_COST);
  format %{ "sve_uunpklo $dst, $src\n\t"
            "sve_neg $dst, $dst\t # vector load mask (B to H)" %}
  ins_encode %{
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H,
                   as_FloatRegister($src$$reg));
    __ sve_neg(as_FloatRegister($dst$$reg), __ H, ptrue,
               as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vloadmaskI(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||
             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));
  match(Set dst (VectorLoadMask src));
  ins_cost(3 * SVE_COST);
  format %{ "sve_uunpklo $dst, $src\n\t"
            "sve_uunpklo $dst, $dst\n\t"
            "sve_neg $dst, $dst\t # vector load mask (B to S)" %}
  ins_encode %{
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H,
                   as_FloatRegister($src$$reg));
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S,
                   as_FloatRegister($dst$$reg));
    __ sve_neg(as_FloatRegister($dst$$reg), __ S, ptrue,
               as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vloadmaskL(vReg dst, vReg src) %{
  predicate(UseSVE > 0 &&
            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||
             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));
  match(Set dst (VectorLoadMask src));
  ins_cost(4 * SVE_COST);
  format %{ "sve_uunpklo $dst, $src\n\t"
            "sve_uunpklo $dst, $dst\n\t"
            "sve_uunpklo $dst, $dst\n\t"
            "sve_neg $dst, $dst\t # vector load mask (B to D)" %}
  ins_encode %{
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H,
                   as_FloatRegister($src$$reg));
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S,
                   as_FloatRegister($dst$$reg));
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ D,
                   as_FloatRegister($dst$$reg));
    __ sve_neg(as_FloatRegister($dst$$reg), __ D, ptrue,
               as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector store mask

instruct vstoremaskB(vReg dst, vReg src, immI_1 size) %{
  predicate(UseSVE > 0);
  match(Set dst (VectorStoreMask src size));
  ins_cost(SVE_COST);
  format %{ "sve_neg $dst, $src\t # vector store mask (B)" %}
  ins_encode %{
    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,
               as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vstoremaskS(vReg dst, vReg src, vReg tmp, immI_2 size) %{
  predicate(UseSVE > 0);
  match(Set dst (VectorStoreMask src size));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(3 * SVE_COST);
  format %{ "sve_dup $tmp, 0\n\t"
            "sve_uzp1 $dst, $src, $tmp\n\t"
            "sve_neg $dst, $dst\t # vector store mask (sve) (H to B)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,
                as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));
    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,
               as_FloatRegister($dst$$reg));

  %}
  ins_pipe(pipe_slow);
%}

instruct vstoremaskI(vReg dst, vReg src, vReg tmp, immI_4 size) %{
  predicate(UseSVE > 0);
  match(Set dst (VectorStoreMask src size));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(4 * SVE_COST);
  format %{ "sve_dup $tmp, 0\n\t"
            "sve_uzp1 $dst, $src, $tmp\n\t"
            "sve_uzp1 $dst, $dst, $tmp\n\t"
            "sve_neg $dst, $dst\t # vector store mask (sve) (S to B)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,
                as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,
                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,
               as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vstoremaskL(vReg dst, vReg src, vReg tmp, immI_8 size) %{
  predicate(UseSVE > 0);
  match(Set dst (VectorStoreMask src size));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(5 * SVE_COST);
  format %{ "sve_dup $tmp, 0\n\t"
            "sve_uzp1 $dst, $src, $tmp\n\t"
            "sve_uzp1 $dst, $dst, $tmp\n\t"
            "sve_uzp1 $dst, $dst, $tmp\n\t"
            "sve_neg $dst, $dst\t # vector store mask (sve) (D to B)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($tmp$$reg), __ D, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S,
                as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,
                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,
                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    __ sve_neg(as_FloatRegister($dst$$reg), __ B, ptrue,
               as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// load/store mask vector

instruct vloadmask_loadV_byte(vReg dst, vmemA mem) %{
  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() == MaxVectorSize &&
            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) == 1);
  match(Set dst (VectorLoadMask (LoadVector mem)));
  ins_cost(5 * SVE_COST);
  format %{ "sve_ld1b $dst, $mem\n\t"
            "sve_neg $dst, $dst\t # load vector mask (sve)" %}
  ins_encode %{
    FloatRegister dst_reg = as_FloatRegister($dst$$reg);
    BasicType to_vect_bt = vector_element_basic_type(this);
    Assembler::SIMD_RegVariant to_vect_variant = elemType_to_regVariant(to_vect_bt);
    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,
                         T_BOOLEAN, to_vect_bt, $mem->opcode(),
                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    __ sve_neg(dst_reg, to_vect_variant, ptrue, dst_reg);
  %}
  ins_pipe(pipe_slow);
%}

instruct vloadmask_loadV_non_byte(vReg dst, indirect mem) %{
  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() == MaxVectorSize &&
            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) > 1);
  match(Set dst (VectorLoadMask (LoadVector mem)));
  ins_cost(5 * SVE_COST);
  format %{ "sve_ld1b $dst, $mem\n\t"
            "sve_neg $dst, $dst\t # load vector mask (sve)" %}
  ins_encode %{
    FloatRegister dst_reg = as_FloatRegister($dst$$reg);
    BasicType to_vect_bt = vector_element_basic_type(this);
    Assembler::SIMD_RegVariant to_vect_variant = elemType_to_regVariant(to_vect_bt);
    loadStoreA_predicate(C2_MacroAssembler(&cbuf), false, dst_reg, ptrue,
                         T_BOOLEAN, to_vect_bt, $mem->opcode(),
                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    __ sve_neg(dst_reg, to_vect_variant, ptrue, dst_reg);
  %}
  ins_pipe(pipe_slow);
%}

instruct storeV_vstoremask_byte(vmemA mem, vReg src, vReg tmp, immI_1 esize) %{
  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() *
                          n->as_StoreVector()->in(MemNode::ValueIn)->in(2)->get_int() == MaxVectorSize);
  match(Set mem (StoreVector mem (VectorStoreMask src esize)));
  effect(TEMP tmp);
  ins_cost(5 * SVE_COST);
  format %{ "sve_neg $tmp, $src\n\t"
            "sve_st1b $tmp, $mem\t # store vector mask (sve)" %}
  ins_encode %{
    BasicType from_vect_bt = vector_element_basic_type(this, $src);
    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, "unsupported type.");
    Assembler::SIMD_RegVariant from_vect_variant = elemBytes_to_regVariant($esize$$constant);
    __ sve_neg(as_FloatRegister($tmp$$reg), from_vect_variant, ptrue,
               as_FloatRegister($src$$reg));
    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, as_FloatRegister($tmp$$reg),
                         ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),
                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
  %}
  ins_pipe(pipe_slow);
%}

instruct storeV_vstoremask_non_byte(indirect mem, vReg src, vReg tmp, immI_gt_1 esize) %{
  predicate(UseSVE > 0 && n->as_StoreVector()->memory_size() *
                          n->as_StoreVector()->in(MemNode::ValueIn)->in(2)->get_int() == MaxVectorSize);
  match(Set mem (StoreVector mem (VectorStoreMask src esize)));
  effect(TEMP tmp);
  ins_cost(5 * SVE_COST);
  format %{ "sve_neg $tmp, $src\n\t"
            "sve_st1b $tmp, $mem\t # store vector mask (sve)" %}
  ins_encode %{
    BasicType from_vect_bt = vector_element_basic_type(this, $src);
    assert(type2aelembytes(from_vect_bt) == (int)$esize$$constant, "unsupported type.");
    Assembler::SIMD_RegVariant from_vect_variant = elemBytes_to_regVariant($esize$$constant);
    __ sve_neg(as_FloatRegister($tmp$$reg), from_vect_variant, ptrue,
               as_FloatRegister($src$$reg));
    loadStoreA_predicate(C2_MacroAssembler(&cbuf), true, as_FloatRegister($tmp$$reg),
                         ptrue, T_BOOLEAN, from_vect_bt, $mem->opcode(),
                         as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
  %}
  ins_pipe(pipe_slow);
%}


// vector add reduction

instruct reduce_addB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (AddReductionVI src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_uaddv $tmp, $src2\t# vector (sve) (B)\n\t"
            "smov  $dst, $tmp, B, 0\n\t"
            "addw  $dst, $dst, $src1\n\t"
            "sxtb  $dst, $dst\t # add reduction B" %}
  ins_encode %{
    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ B,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);
    __ addw($dst$$Register, $dst$$Register, $src1$$Register);
    __ sxtb($dst$$Register, $dst$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_addS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (AddReductionVI src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_uaddv $tmp, $src2\t# vector (sve) (H)\n\t"
            "smov  $dst, $tmp, H, 0\n\t"
            "addw  $dst, $dst, $src1\n\t"
            "sxth  $dst, $dst\t # add reduction H" %}
  ins_encode %{
    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ H,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);
    __ addw($dst$$Register, $dst$$Register, $src1$$Register);
    __ sxth($dst$$Register, $dst$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (AddReductionVI src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_uaddv $tmp, $src2\t# vector (sve) (S)\n\t"
            "umov  $dst, $tmp, S, 0\n\t"
            "addw  $dst, $dst, $src1\t # add reduction S" %}
  ins_encode %{
    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
    __ addw($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (AddReductionVL src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_uaddv $tmp, $src2\t# vector (sve) (D)\n\t"
            "umov  $dst, $tmp, D, 0\n\t"
            "add  $dst, $dst, $src1\t # add reduction D" %}
  ins_encode %{
    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);
    __ add($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_addF(vRegF src1_dst, vReg src2) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set src1_dst (AddReductionVF src1_dst src2));
  ins_cost(SVE_COST);
  format %{ "sve_fadda $src1_dst, $src1_dst, $src2\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_addD(vRegD src1_dst, vReg src2) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set src1_dst (AddReductionVD src1_dst src2));
  ins_cost(SVE_COST);
  format %{ "sve_fadda $src1_dst, $src1_dst, $src2\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_addI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (AddReductionVI src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_addI $dst, $src1, $src2\t# addI reduction partial (sve) (may extend)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this, $src2);
    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), variant, zr, rscratch1);
    __ sve_uaddv(as_FloatRegister($vtmp$$reg), variant,
                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);
    __ addw($dst$$Register, $dst$$Register, $src1$$Register);
    if (bt == T_BYTE) {
      __ sxtb($dst$$Register, $dst$$Register);
    } else if (bt == T_SHORT) {
      __ sxth($dst$$Register, $dst$$Register);
    }
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_addL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (AddReductionVL src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_addL $dst, $src1, $src2\t# addL reduction partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);
    __ sve_uaddv(as_FloatRegister($vtmp$$reg), __ D,
                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);
    __ add($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_addF_partial(vRegF src1_dst, vReg src2, pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set src1_dst (AddReductionVF src1_dst src2));
  ins_cost(SVE_COST);
  effect(TEMP ptmp, KILL cr);
  format %{ "sve_fadda $src1_dst, $src1_dst, $src2\t# vector (sve) (S)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ S, zr, rscratch1);
    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,
                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_addD_partial(vRegD src1_dst, vReg src2, pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set src1_dst (AddReductionVD src1_dst src2));
  ins_cost(SVE_COST);
  effect(TEMP ptmp, KILL cr);
  format %{ "sve_fadda $src1_dst, $src1_dst, $src2\t# vector (sve) (D)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);
    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,
                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector and reduction

instruct reduce_andB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (AndReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_andv $tmp, $src2\t# vector (sve) (B)\n\t"
            "smov  $dst, $tmp, B, 0\n\t"
            "andw  $dst, $dst, $src1\n\t"
            "sxtb  $dst, $dst\t # and reduction B" %}
  ins_encode %{
    __ sve_andv(as_FloatRegister($tmp$$reg), __ B,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);
    __ andw($dst$$Register, $dst$$Register, $src1$$Register);
    __ sxtb($dst$$Register, $dst$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_andS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (AndReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_andv $tmp, $src2\t# vector (sve) (H)\n\t"
            "smov  $dst, $tmp, H, 0\n\t"
            "andw  $dst, $dst, $src1\n\t"
            "sxth  $dst, $dst\t # and reduction H" %}
  ins_encode %{
    __ sve_andv(as_FloatRegister($tmp$$reg), __ H,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);
    __ andw($dst$$Register, $dst$$Register, $src1$$Register);
    __ sxth($dst$$Register, $dst$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (AndReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_andv $tmp, $src2\t# vector (sve) (S)\n\t"
            "umov  $dst, $tmp, S, 0\n\t"
            "andw  $dst, $dst, $src1\t # and reduction S" %}
  ins_encode %{
    __ sve_andv(as_FloatRegister($tmp$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
    __ andw($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_andL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (AndReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_andv $tmp, $src2\t# vector (sve) (D)\n\t"
            "umov  $dst, $tmp, D, 0\n\t"
            "andr  $dst, $dst, $src1\t # and reduction D" %}
  ins_encode %{
    __ sve_andv(as_FloatRegister($tmp$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);
    __ andr($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_andI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (AndReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_andI $dst, $src1, $src2\t# andI reduction partial (sve) (may extend)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this, $src2);
    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), variant, zr, rscratch1);
    __ sve_andv(as_FloatRegister($vtmp$$reg), variant,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);
    __ andw($dst$$Register, $dst$$Register, $src1$$Register);
    if (bt == T_BYTE) {
      __ sxtb($dst$$Register, $dst$$Register);
    } else if (bt == T_SHORT) {
      __ sxth($dst$$Register, $dst$$Register);
    }
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_andL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (AndReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_andL $dst, $src1, $src2\t# andL reduction partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);
    __ sve_andv(as_FloatRegister($vtmp$$reg), __ D,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);
    __ andr($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}


// vector or reduction

instruct reduce_orB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (OrReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_orv $tmp, $src2\t# vector (sve) (B)\n\t"
            "smov  $dst, $tmp, B, 0\n\t"
            "orrw  $dst, $dst, $src1\n\t"
            "sxtb  $dst, $dst\t # or reduction B" %}
  ins_encode %{
    __ sve_orv(as_FloatRegister($tmp$$reg), __ B,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);
    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);
    __ sxtb($dst$$Register, $dst$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_orS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (OrReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_orv $tmp, $src2\t# vector (sve) (H)\n\t"
            "smov  $dst, $tmp, H, 0\n\t"
            "orrw  $dst, $dst, $src1\n\t"
            "sxth  $dst, $dst\t # or reduction H" %}
  ins_encode %{
    __ sve_orv(as_FloatRegister($tmp$$reg), __ H,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);
    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);
    __ sxth($dst$$Register, $dst$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (OrReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_orv $tmp, $src2\t# vector (sve) (S)\n\t"
            "umov  $dst, $tmp, S, 0\n\t"
            "orrw  $dst, $dst, $src1\t # or reduction S" %}
  ins_encode %{
    __ sve_orv(as_FloatRegister($tmp$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_orL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (OrReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_orv $tmp, $src2\t# vector (sve) (D)\n\t"
            "umov  $dst, $tmp, D, 0\n\t"
            "orr  $dst, $dst, $src1\t # or reduction D" %}
  ins_encode %{
    __ sve_orv(as_FloatRegister($tmp$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);
    __ orr($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_orI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (OrReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_orI $dst, $src1, $src2\t# orI reduction partial (sve) (may extend)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this, $src2);
    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), variant, zr, rscratch1);
    __ sve_orv(as_FloatRegister($vtmp$$reg), variant,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);
    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);
    if (bt == T_BYTE) {
      __ sxtb($dst$$Register, $dst$$Register);
    } else if (bt == T_SHORT) {
      __ sxth($dst$$Register, $dst$$Register);
    }
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_orL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (OrReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_orL $dst, $src1, $src2\t# orL reduction partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);
    __ sve_orv(as_FloatRegister($vtmp$$reg), __ D,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);
    __ orr($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}


// vector xor reduction

instruct reduce_eorB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 &&
            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (XorReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_eorv $tmp, $src2\t# vector (sve) (B)\n\t"
            "smov  $dst, $tmp, B, 0\n\t"
            "eorw  $dst, $dst, $src1\n\t"
            "sxtb  $dst, $dst\t # eor reduction B" %}
  ins_encode %{
    __ sve_eorv(as_FloatRegister($tmp$$reg), __ B,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);
    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);
    __ sxtb($dst$$Register, $dst$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_eorS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 &&
            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (XorReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_eorv $tmp, $src2\t# vector (sve) (H)\n\t"
            "smov  $dst, $tmp, H, 0\n\t"
            "eorw  $dst, $dst, $src1\n\t"
            "sxth  $dst, $dst\t # eor reduction H" %}
  ins_encode %{
    __ sve_eorv(as_FloatRegister($tmp$$reg), __ H,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);
    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);
    __ sxth($dst$$Register, $dst$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_eorI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 &&
            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (XorReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_eorv $tmp, $src2\t# vector (sve) (S)\n\t"
            "umov  $dst, $tmp, S, 0\n\t"
            "eorw  $dst, $dst, $src1\t # eor reduction S" %}
  ins_encode %{
    __ sve_eorv(as_FloatRegister($tmp$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_eorL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{
  predicate(UseSVE > 0 &&
            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (XorReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  ins_cost(SVE_COST);
  format %{ "sve_eorv $tmp, $src2\t# vector (sve) (D)\n\t"
            "umov  $dst, $tmp, D, 0\n\t"
            "eor  $dst, $dst, $src1\t # eor reduction D" %}
  ins_encode %{
    __ sve_eorv(as_FloatRegister($tmp$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);
    __ eor($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_eorI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (XorReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_orI $dst, $src1, $src2\t# xorI reduction partial (sve) (may extend)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this, $src2);
    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), variant, zr, rscratch1);
    __ sve_eorv(as_FloatRegister($vtmp$$reg), variant,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);
    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);
    if (bt == T_BYTE) {
      __ sxtb($dst$$Register, $dst$$Register);
    } else if (bt == T_SHORT) {
      __ sxth($dst$$Register, $dst$$Register);
    }
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_eorL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (XorReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_orL $dst, $src1, $src2\t# xorL reduction partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);
    __ sve_eorv(as_FloatRegister($vtmp$$reg), __ D,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);
    __ eor($dst$$Register, $dst$$Register, $src1$$Register);
  %}
  ins_pipe(pipe_slow);
%}


// vector max reduction

instruct reduce_maxB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MaxReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_smaxv $tmp, $src2\t# vector (sve) (B)\n\t"
            "smov  $dst, $tmp, B, 0\n\t"
            "cmpw  $dst, $src1\n\t"
            "cselw $dst, $dst, $src1 GT\t# max reduction B" %}
  ins_encode %{
    __ sve_smaxv(as_FloatRegister($tmp$$reg), __ B,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);
    __ cmpw($dst$$Register, $src1$$Register);
    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_maxS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MaxReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_smaxv $tmp, $src2\t# vector (sve) (H)\n\t"
            "smov  $dst, $tmp, H, 0\n\t"
            "cmpw  $dst, $src1\n\t"
            "cselw $dst, $dst, $src1 GT\t# max reduction H" %}
  ins_encode %{
    __ sve_smaxv(as_FloatRegister($tmp$$reg), __ H,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);
    __ cmpw($dst$$Register, $src1$$Register);
    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_maxI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MaxReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_smaxv $tmp, $src2\t# vector (sve) (S)\n\t"
            "smov  $dst, $tmp, S, 0\n\t"
            "cmpw  $dst, $src1\n\t"
            "cselw $dst, $dst, $src1 GT\t# max reduction S" %}
  ins_encode %{
    __ sve_smaxv(as_FloatRegister($tmp$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
    __ cmpw($dst$$Register, $src1$$Register);
    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_maxL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MaxReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_smaxv $tmp, $src2\t# vector (sve) (D)\n\t"
            "smov  $dst, $tmp, D, 0\n\t"
            "cmp  $dst, $src1\n\t"
            "csel $dst, $dst, $src1 GT\t# max reduction D" %}
  ins_encode %{
    __ sve_smaxv(as_FloatRegister($tmp$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);
    __ cmp($dst$$Register, $src1$$Register);
    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_maxI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&
            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||
             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||
             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));
  match(Set dst (MaxReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_maxI $dst, $src1, $src2\t# reduce maxI partial (sve)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this, $src2);
    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), variant, zr, rscratch1);
    __ sve_smaxv(as_FloatRegister($vtmp$$reg), variant,
                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);
    __ cmpw($dst$$Register, $src1$$Register);
    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_maxL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&
            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (MaxReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_maxL $dst, $src1, $src2\t# reduce maxL partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);
    __ sve_smaxv(as_FloatRegister($vtmp$$reg), __ D,
                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);
    __ cmp($dst$$Register, $src1$$Register);
    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_maxF(vRegF dst, vRegF src1, vReg src2) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MaxReductionV src1 src2));
  ins_cost(INSN_COST);
  effect(TEMP_DEF dst);
  format %{ "sve_fmaxv $dst, $src2 # vector (sve) (S)\n\t"
            "fmaxs $dst, $dst, $src1\t # max reduction F" %}
  ins_encode %{
    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_maxD(vRegD dst, vRegD src1, vReg src2) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MaxReductionV src1 src2));
  ins_cost(INSN_COST);
  effect(TEMP_DEF dst);
  format %{ "sve_fmaxv $dst, $src2 # vector (sve) (D)\n\t"
            "fmaxs $dst, $dst, $src1\t # max reduction D" %}
  ins_encode %{
    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_maxF_partial(vRegF dst, vRegF src1, vReg src2,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (MaxReductionV src1 src2));
  ins_cost(INSN_COST);
  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);
  format %{ "sve_reduce_S $dst, $src1, $src2\t# reduce max S partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ S, zr, rscratch1);
    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ S,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_maxD_partial(vRegD dst, vRegD src1, vReg src2,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (MaxReductionV src1 src2));
  ins_cost(INSN_COST);
  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);
  format %{ "sve_reduce_D $dst, $src1, $src2\t# reduce max D partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);
    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector min reduction

instruct reduce_minB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MinReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_sminv $tmp, $src2\t# vector (sve) (B)\n\t"
            "smov  $dst, $tmp, B, 0\n\t"
            "cmpw  $dst, $src1\n\t"
            "cselw $dst, $dst, $src1 LT\t# min reduction B" %}
  ins_encode %{
    __ sve_sminv(as_FloatRegister($tmp$$reg), __ B,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);
    __ cmpw($dst$$Register, $src1$$Register);
    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_minS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MinReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_sminv $tmp, $src2\t# vector (sve) (H)\n\t"
            "smov  $dst, $tmp, H, 0\n\t"
            "cmpw  $dst, $src1\n\t"
            "cselw $dst, $dst, $src1 LT\t# min reduction H" %}
  ins_encode %{
    __ sve_sminv(as_FloatRegister($tmp$$reg), __ H,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);
    __ cmpw($dst$$Register, $src1$$Register);
    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_minI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MinReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_sminv $tmp, $src2\t# vector (sve) (S)\n\t"
            "smov  $dst, $tmp, S, 0\n\t"
            "cmpw  $dst, $src1\n\t"
            "cselw $dst, $dst, $src1 LT\t# min reduction S" %}
  ins_encode %{
    __ sve_sminv(as_FloatRegister($tmp$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
    __ cmpw($dst$$Register, $src1$$Register);
    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_minL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MinReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_sminv $tmp, $src2\t# vector (sve) (D)\n\t"
            "smov  $dst, $tmp, D, 0\n\t"
            "cmp  $dst, $src1\n\t"
            "csel $dst, $dst, $src1 LT\t# min reduction D" %}
  ins_encode %{
    __ sve_sminv(as_FloatRegister($tmp$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);
    __ cmp($dst$$Register, $src1$$Register);
    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_minI_partial(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&
            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||
             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||
             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));
  match(Set dst (MinReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_minI $dst, $src1, $src2\t# reduce minI partial (sve)" %}
  ins_encode %{
    BasicType bt = vector_element_basic_type(this, $src2);
    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), variant, zr, rscratch1);
    __ sve_sminv(as_FloatRegister($vtmp$$reg), variant,
                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);
    __ cmpw($dst$$Register, $src1$$Register);
    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_minL_partial(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&
            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (MinReductionV src1 src2));
  effect(TEMP_DEF dst, TEMP vtmp, TEMP ptmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_reduce_minL $dst, $src1, $src2\t# reduce minL partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);
    __ sve_sminv(as_FloatRegister($vtmp$$reg), __ D,
                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);
    __ cmp($dst$$Register, $src1$$Register);
    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_minF(vRegF dst, vRegF src1, vReg src2) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MinReductionV src1 src2));
  ins_cost(INSN_COST);
  effect(TEMP_DEF dst);
  format %{ "sve_fminv $dst, $src2 # vector (sve) (S)\n\t"
            "fmins $dst, $dst, $src1\t # min reduction F" %}
  ins_encode %{
    __ sve_fminv(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($src2$$reg));
    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_minD(vRegD dst, vRegD src1, vReg src2) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);
  match(Set dst (MinReductionV src1 src2));
  ins_cost(INSN_COST);
  effect(TEMP_DEF dst);
  format %{ "sve_fminv $dst, $src2 # vector (sve) (D)\n\t"
            "fmins $dst, $dst, $src1\t # min reduction D" %}
  ins_encode %{
    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($src2$$reg));
    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_minF_partial(vRegF dst, vRegF src1, vReg src2,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (MinReductionV src1 src2));
  ins_cost(INSN_COST);
  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);
  format %{ "sve_reduce_S $dst, $src1, $src2\t# reduce min S partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ S, zr, rscratch1);
    __ sve_fminv(as_FloatRegister($dst$$reg), __ S,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct reduce_minD_partial(vRegD dst, vRegD src1, vReg src2,
                             pRegGov ptmp, rFlagsReg cr) %{
  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&
            n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);
  match(Set dst (MinReductionV src1 src2));
  ins_cost(INSN_COST);
  effect(TEMP_DEF dst, TEMP ptmp, KILL cr);
  format %{ "sve_reduce_D $dst, $src1, $src2\t# reduce min D partial (sve)" %}
  ins_encode %{
    __ mov(rscratch1, vector_length(this, $src2));
    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);
    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,
         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));
    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector Math.rint, floor, ceil

instruct vroundD(vReg dst, vReg src, immI rmode) %{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
  match(Set dst (RoundDoubleModeV src rmode));
  format %{ "sve_frint $dst, $src, $rmode\t# vector (sve) (D)" %}
  ins_encode %{
    switch ($rmode$$constant) {
      case RoundDoubleModeNode::rmode_rint:
        __ sve_frintn(as_FloatRegister($dst$$reg), __ D,
             ptrue, as_FloatRegister($src$$reg));
        break;
      case RoundDoubleModeNode::rmode_floor:
        __ sve_frintm(as_FloatRegister($dst$$reg), __ D,
             ptrue, as_FloatRegister($src$$reg));
        break;
      case RoundDoubleModeNode::rmode_ceil:
        __ sve_frintp(as_FloatRegister($dst$$reg), __ D,
             ptrue, as_FloatRegister($src$$reg));
        break;
    }
  %}
  ins_pipe(pipe_slow);
%}

// vector replicate

instruct replicateB(vReg dst, iRegIorL2I src) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateB src));
  ins_cost(SVE_COST);
  format %{ "sve_dup  $dst, $src\t# vector (sve) (B)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct replicateS(vReg dst, iRegIorL2I src) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateS src));
  ins_cost(SVE_COST);
  format %{ "sve_dup  $dst, $src\t# vector (sve) (H)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct replicateI(vReg dst, iRegIorL2I src) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateI src));
  ins_cost(SVE_COST);
  format %{ "sve_dup  $dst, $src\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct replicateL(vReg dst, iRegL src) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateL src));
  ins_cost(SVE_COST);
  format %{ "sve_dup  $dst, $src\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct replicateB_imm8(vReg dst, immI8 con) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateB con));
  ins_cost(SVE_COST);
  format %{ "sve_dup  $dst, $con\t# vector (sve) (B)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ B, $con$$constant);
  %}
  ins_pipe(pipe_slow);
%}

instruct replicateS_imm8(vReg dst, immI8_shift8 con) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateS con));
  ins_cost(SVE_COST);
  format %{ "sve_dup  $dst, $con\t# vector (sve) (H)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ H, $con$$constant);
  %}
  ins_pipe(pipe_slow);
%}

instruct replicateI_imm8(vReg dst, immI8_shift8 con) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateI con));
  ins_cost(SVE_COST);
  format %{ "sve_dup  $dst, $con\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ S, $con$$constant);
  %}
  ins_pipe(pipe_slow);
%}

instruct replicateL_imm8(vReg dst, immL8_shift8 con) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateL con));
  ins_cost(SVE_COST);
  format %{ "sve_dup  $dst, $con\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ D, $con$$constant);
  %}
  ins_pipe(pipe_slow);
%}

instruct replicateF(vReg dst, vRegF src) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateF src));
  ins_cost(SVE_COST);
  format %{ "sve_cpy  $dst, $src\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct replicateD(vReg dst, vRegD src) %{
  predicate(UseSVE > 0);
  match(Set dst (ReplicateD src));
  ins_cost(SVE_COST);
  format %{ "sve_cpy  $dst, $src\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector shift

instruct vasrB(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (RShiftVB dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_asr $dst, $dst, $shift\t# vector (sve) (B)" %}
  ins_encode %{
    __ sve_asr(as_FloatRegister($dst$$reg), __ B,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vasrS(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (RShiftVS dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_asr $dst, $dst, $shift\t# vector (sve) (H)" %}
  ins_encode %{
    __ sve_asr(as_FloatRegister($dst$$reg), __ H,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vasrI(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (RShiftVI dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_asr $dst, $dst, $shift\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_asr(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vasrL(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (RShiftVL dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_asr $dst, $dst, $shift\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_asr(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vlslB(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (LShiftVB dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_lsl $dst, $dst, $shift\t# vector (sve) (B)" %}
  ins_encode %{
    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vlslS(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (LShiftVS dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_lsl $dst, $dst, $shift\t# vector (sve) (H)" %}
  ins_encode %{
    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vlslI(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (LShiftVI dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_lsl $dst, $dst, $shift\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vlslL(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (LShiftVL dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_lsl $dst, $dst, $shift\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vlsrB(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (URShiftVB dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_lsr $dst, $dst, $shift\t# vector (sve) (B)" %}
  ins_encode %{
    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vlsrS(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (URShiftVS dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_lsr $dst, $dst, $shift\t# vector (sve) (H)" %}
  ins_encode %{
    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vlsrI(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (URShiftVI dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_lsr $dst, $dst, $shift\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vlsrL(vReg dst, vReg shift) %{
  predicate(UseSVE > 0);
  match(Set dst (URShiftVL dst shift));
  ins_cost(SVE_COST);
  format %{ "sve_lsr $dst, $dst, $shift\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($shift$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vasrB_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (RShiftVB src (RShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_asr $dst, $src, $shift\t# vector (sve) (B)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con == 0) {
      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    if (con >= 8) con = 7;
    __ sve_asr(as_FloatRegister($dst$$reg), __ B,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vasrS_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (RShiftVS src (RShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_asr $dst, $src, $shift\t# vector (sve) (H)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con == 0) {
      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    if (con >= 16) con = 15;
    __ sve_asr(as_FloatRegister($dst$$reg), __ H,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vasrI_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (RShiftVI src (RShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_asr $dst, $src, $shift\t# vector (sve) (S)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con == 0) {
      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    __ sve_asr(as_FloatRegister($dst$$reg), __ S,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vasrL_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (RShiftVL src (RShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_asr $dst, $src, $shift\t# vector (sve) (D)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con == 0) {
      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    __ sve_asr(as_FloatRegister($dst$$reg), __ D,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vlsrB_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (URShiftVB src (RShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_lsr $dst, $src, $shift\t# vector (sve) (B)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con == 0) {
      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    if (con >= 8) {
      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    __ sve_lsr(as_FloatRegister($dst$$reg), __ B,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vlsrS_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (URShiftVS src (RShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_lsr $dst, $src, $shift\t# vector (sve) (H)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con == 0) {
      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    if (con >= 16) {
      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    __ sve_lsr(as_FloatRegister($dst$$reg), __ H,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vlsrI_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (URShiftVI src (RShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_lsr $dst, $src, $shift\t# vector (sve) (S)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con == 0) {
      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    __ sve_lsr(as_FloatRegister($dst$$reg), __ S,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vlsrL_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (URShiftVL src (RShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_lsr $dst, $src, $shift\t# vector (sve) (D)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con == 0) {
      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    __ sve_lsr(as_FloatRegister($dst$$reg), __ D,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vlslB_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (LShiftVB src (LShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_lsl $dst, $src, $shift\t# vector (sve) (B)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con >= 8) {
      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    __ sve_lsl(as_FloatRegister($dst$$reg), __ B,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vlslS_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (LShiftVS src (LShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_lsl $dst, $src, $shift\t# vector (sve) (H)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    if (con >= 16) {
      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),
           as_FloatRegister($src$$reg));
      return;
    }
    __ sve_lsl(as_FloatRegister($dst$$reg), __ H,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vlslI_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (LShiftVI src (LShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_lsl $dst, $src, $shift\t# vector (sve) (S)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    __ sve_lsl(as_FloatRegister($dst$$reg), __ S,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vlslL_imm(vReg dst, vReg src, immI shift) %{
  predicate(UseSVE > 0);
  match(Set dst (LShiftVL src (LShiftCntV shift)));
  ins_cost(SVE_COST);
  format %{ "sve_lsl $dst, $src, $shift\t# vector (sve) (D)" %}
  ins_encode %{
    int con = (int)$shift$$constant;
    __ sve_lsl(as_FloatRegister($dst$$reg), __ D,
         as_FloatRegister($src$$reg), con);
  %}
  ins_pipe(pipe_slow);
%}

instruct vshiftcntB(vReg dst, iRegIorL2I cnt) %{
  predicate(UseSVE > 0 &&
            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE));
  match(Set dst (LShiftCntV cnt));
  match(Set dst (RShiftCntV cnt));
  format %{ "sve_dup $dst, $cnt\t# vector shift count (sve) (B)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ B, as_Register($cnt$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vshiftcntS(vReg dst, iRegIorL2I cnt) %{
  predicate(UseSVE > 0 &&
            (n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||
            (n->bottom_type()->is_vect()->element_basic_type() == T_CHAR)));
  match(Set dst (LShiftCntV cnt));
  match(Set dst (RShiftCntV cnt));
  format %{ "sve_dup $dst, $cnt\t# vector shift count (sve) (H)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ H, as_Register($cnt$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vshiftcntI(vReg dst, iRegIorL2I cnt) %{
  predicate(UseSVE > 0 &&
            (n->bottom_type()->is_vect()->element_basic_type() == T_INT));
  match(Set dst (LShiftCntV cnt));
  match(Set dst (RShiftCntV cnt));
  format %{ "sve_dup $dst, $cnt\t# vector shift count (sve) (S)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ S, as_Register($cnt$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vshiftcntL(vReg dst, iRegIorL2I cnt) %{
  predicate(UseSVE > 0 &&
            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG));
  match(Set dst (LShiftCntV cnt));
  match(Set dst (RShiftCntV cnt));
  format %{ "sve_dup $dst, $cnt\t# vector shift count (sve) (D)" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($dst$$reg), __ D, as_Register($cnt$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector sqrt

instruct vsqrtF(vReg dst, vReg src) %{
  predicate(UseSVE > 0);
  match(Set dst (SqrtVF src));
  ins_cost(SVE_COST);
  format %{ "sve_fsqrt $dst, $src\t# vector (sve) (S)" %}
  ins_encode %{
    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ S,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vsqrtD(vReg dst, vReg src) %{
  predicate(UseSVE > 0);
  match(Set dst (SqrtVD src));
  ins_cost(SVE_COST);
  format %{ "sve_fsqrt $dst, $src\t# vector (sve) (D)" %}
  ins_encode %{
    __ sve_fsqrt(as_FloatRegister($dst$$reg), __ D,
         ptrue, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// vector sub

instruct vsubB(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (SubVB src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_sub $dst, $src1, $src2\t # vector (sve) (B)" %}
  ins_encode %{
    __ sve_sub(as_FloatRegister($dst$$reg), __ B,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vsubS(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (SubVS src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_sub $dst, $src1, $src2\t # vector (sve) (H)" %}
  ins_encode %{
    __ sve_sub(as_FloatRegister($dst$$reg), __ H,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vsubI(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (SubVI src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_sub $dst, $src1, $src2\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_sub(as_FloatRegister($dst$$reg), __ S,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vsubL(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (SubVL src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_sub $dst, $src1, $src2\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_sub(as_FloatRegister($dst$$reg), __ D,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vsubF(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (SubVF src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_fsub $dst, $src1, $src2\t # vector (sve) (S)" %}
  ins_encode %{
    __ sve_fsub(as_FloatRegister($dst$$reg), __ S,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vsubD(vReg dst, vReg src1, vReg src2) %{
  predicate(UseSVE > 0);
  match(Set dst (SubVD src1 src2));
  ins_cost(SVE_COST);
  format %{ "sve_fsub $dst, $src1, $src2\t # vector (sve) (D)" %}
  ins_encode %{
    __ sve_fsub(as_FloatRegister($dst$$reg), __ D,
         as_FloatRegister($src1$$reg),
         as_FloatRegister($src2$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// ------------------------------ Vector cast -------------------------------

instruct vcvtBtoS(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorCastB2X src));
  ins_cost(SVE_COST);
  format %{ "sve_sunpklo  $dst, H, $src\t# convert B to S vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtStoI(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_INT);
  match(Set dst (VectorCastS2X src));
  ins_cost(SVE_COST);
  format %{ "sve_sunpklo  $dst, S, $src\t# convert S to I vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtItoL(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (VectorCastI2X src));
  ins_cost(SVE_COST);
  format %{ "sve_sunpklo  $dst, D, $src\t# convert I to L vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtBtoI(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_INT);
  match(Set dst (VectorCastB2X src));
  ins_cost(2 * SVE_COST);
  format %{ "sve_sunpklo  $dst, H, $src\n\t"
            "sve_sunpklo  $dst, S, $dst\t# convert B to I vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtStoL(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (VectorCastS2X src));
  ins_cost(2 * SVE_COST);
  format %{ "sve_sunpklo  $dst, S, $src\n\t"
            "sve_sunpklo  $dst, D, $dst\t# convert S to L vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtBtoL(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (VectorCastB2X src));
  ins_cost(3 * SVE_COST);
  format %{ "sve_sunpklo  $dst, H, $src\n\t"
            "sve_sunpklo  $dst, S, $dst\n\t"
            "sve_sunpklo  $dst, D, $dst\t# convert B to L vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtStoB(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorCastS2X src));
  effect(TEMP tmp);
  ins_cost(2 * SVE_COST);
  format %{ "sve_dup  $tmp, B, 0\n\t"
            "sve_uzp1  $dst, B, $src, tmp\t# convert S to B vector" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($tmp$$reg), __ B, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtItoS(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorCastI2X src));
  effect(TEMP tmp);
  ins_cost(2 * SVE_COST);
  format %{ "sve_dup  $tmp, H, 0\n\t"
            "sve_uzp1  $dst, H, $src, tmp\t# convert I to S vector" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtLtoI(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_INT);
  match(Set dst (VectorCastL2X src));
  effect(TEMP tmp);
  ins_cost(2 * SVE_COST);
  format %{ "sve_dup  $tmp, S, 0\n\t"
            "sve_uzp1  $dst, S, $src, tmp\t# convert L to I vector" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtItoB(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorCastI2X src));
  effect(TEMP tmp);
  ins_cost(3 * SVE_COST);
  format %{ "sve_dup  $tmp, H, 0\n\t"
            "sve_uzp1  $dst, H, $src, tmp\n\t"
            "sve_uzp1  $dst, B, $dst, tmp\n\t# convert I to B vector" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtLtoS(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorCastL2X src));
  effect(TEMP tmp);
  ins_cost(3 * SVE_COST);
  format %{ "sve_dup  $tmp, S, 0\n\t"
            "sve_uzp1  $dst, S, $src, tmp\n\t"
            "sve_uzp1  $dst, H, $dst, tmp\n\t# convert L to S vector" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtLtoB(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorCastL2X src));
  effect(TEMP tmp);
  ins_cost(4 * SVE_COST);
  format %{ "sve_dup  $tmp, S, 0\n\t"
            "sve_uzp1  $dst, S, $src, tmp\n\t"
            "sve_uzp1  $dst, H, $dst, tmp\n\t"
            "sve_uzp1  $dst, B, $dst, tmp\n\t# convert L to B vector" %}
  ins_encode %{
    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtBtoF(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
  match(Set dst (VectorCastB2X src));
  ins_cost(3 * SVE_COST);
  format %{ "sve_sunpklo  $dst, H, $src\n\t"
            "sve_sunpklo  $dst, S, $dst\n\t"
            "sve_scvtf  $dst, S, $dst, S\t# convert B to F vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));
    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtStoD(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
  match(Set dst (VectorCastS2X src));
  ins_cost(3 * SVE_COST);
  format %{ "sve_sunpklo  $dst, S, $src\n\t"
            "sve_sunpklo  $dst, D, $dst\n\t"
            "sve_scvtf  $dst, D, $dst, D\t# convert S to D vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));
    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtBtoD(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
  match(Set dst (VectorCastB2X src));
  ins_cost(4 * SVE_COST);
  format %{ "sve_sunpklo  $dst, H, $src\n\t"
            "sve_sunpklo  $dst, S, $dst\n\t"
            "sve_sunpklo  $dst, D, $dst\n\t"
            "sve_scvtf  $dst, D, $dst, D\t# convert B to D vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));
    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtLtoF(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
  match(Set dst (VectorCastL2X src));
  effect(TEMP tmp);
  ins_cost(3 * SVE_COST);
  format %{ "sve_scvtf  $dst, S, $src, D\n\t"
            "sve_dup  $tmp, S, 0\n\t"
            "sve_uzp1  $dst, S, $dst, $tmp\t# convert L to F vector" %}
  ins_encode %{
    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);
    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtDtoF(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
  match(Set dst (VectorCastD2X src));
  effect(TEMP tmp);
  ins_cost(3 * SVE_COST);
  format %{ "sve_fcvt  $dst, S, $src, D\n\t"
            "sve_dup  $tmp, S, 0\n\t"
            "sve_uzp1  $dst, S, $dst, $tmp\t# convert D to F vector" %}
  ins_encode %{
    __ sve_fcvt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);
    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtItoF(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
  match(Set dst (VectorCastI2X src));
  ins_cost(SVE_COST);
  format %{ "sve_scvtf  $dst, S, $src, S\t# convert I to F vector" %}
  ins_encode %{
    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtLtoD(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
  match(Set dst (VectorCastL2X src));
  ins_cost(SVE_COST);
  format %{ "sve_scvtf  $dst, D, $src, D\t# convert L to D vector" %}
  ins_encode %{
    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtFtoI(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_INT);
  match(Set dst (VectorCastF2X src));
  ins_cost(SVE_COST);
  format %{ "sve_fcvtzs  $dst, S, $src, S\t# convert F to I vector" %}
  ins_encode %{
    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtDtoL(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (VectorCastD2X src));
  ins_cost(SVE_COST);
  format %{ "sve_fcvtzs  $dst, D, $src, D\t# convert D to L vector" %}
  ins_encode %{
    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtItoD(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
  match(Set dst (VectorCastI2X src));
  ins_cost(2 * SVE_COST);
  format %{ "sve_sunpklo  $dst, D, $src\n\t"
            "sve_scvtf  $dst, D, $dst, D\t# convert I to D vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));
    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtStoF(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
  match(Set dst (VectorCastS2X src));
  ins_cost(2 * SVE_COST);
  format %{ "sve_sunpklo  $dst, S, $src\n\t"
            "sve_scvtf  $dst, S, $dst, S\t# convert S to F vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));
    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtFtoD(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
  match(Set dst (VectorCastF2X src));
  ins_cost(2 * SVE_COST);
  format %{ "sve_sunpklo  $dst, D, $src\n\t"
            "sve_fcvt  $dst, D, $dst, S\t# convert F to D vector" %}
  ins_encode %{
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));
    __ sve_fcvt(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtFtoS(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorCastF2X src));
  effect(TEMP tmp);
  ins_cost(3 * SVE_COST);
  format %{ "sve_fcvtzs  $dst, S, $src, S\n\t"
            "sve_dup  $tmp, H, 0\n\t"
            "sve_uzp1  $dst, H, $dst, tmp\t# convert F to S vector" %}
  ins_encode %{
    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);
    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtDtoI(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_INT);
  match(Set dst (VectorCastD2X src));
  effect(TEMP tmp);
  ins_cost(3 * SVE_COST);
  format %{ "sve_fcvtzs  $dst, D, $src, D\n\t"
            "sve_dup  $tmp, S, 0\n\t"
            "sve_uzp1  $dst, S, $dst, tmp\t# convert D to I vector" %}
  ins_encode %{
    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);
    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}



instruct vcvtFtoB(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorCastF2X src));
  effect(TEMP tmp);
  ins_cost(4 * SVE_COST);
  format %{ "sve_fcvtzs  $dst, S, $src, S\n\t"
            "sve_dup  $tmp, H, 0\n\t"
            "sve_uzp1  $dst, H, $dst, tmp\n\t"
            "sve_uzp1  $dst, B, $dst, tmp\n\t# convert F to B vector" %}
  ins_encode %{
    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);
    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct vcvtDtoS(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorCastD2X src));
  effect(TEMP tmp);
  ins_cost(4 * SVE_COST);
  format %{ "sve_fcvtzs  $dst, D, $src, D\n\t"
            "sve_dup  $tmp, S, 0\n\t"
            "sve_uzp1  $dst, S, $dst, tmp\n\t"
            "sve_uzp1  $dst, H, $dst, tmp\n\t# convert D to S vector" %}
  ins_encode %{
    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);
    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}



instruct vcvtFtoL(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (VectorCastF2X src));
  ins_cost(2 * SVE_COST);
  format %{ "sve_fcvtzs  $dst, S, $src, S\n\t"
            "sve_sunpklo  $dst, D, $dst\t# convert F to L vector" %}
  ins_encode %{
    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);
    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct vcvtDtoB(vReg dst, vReg src, vReg tmp)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorCastD2X src));
  effect(TEMP tmp);
  ins_cost(5 * SVE_COST);
  format %{ "sve_fcvtzs  $dst, D, $src, D\n\t"
            "sve_dup  $tmp, S, 0\n\t"
            "sve_uzp1  $dst, S, $dst, tmp\n\t"
            "sve_uzp1  $dst, H, $dst, tmp\n\t"
            "sve_uzp1  $dst, B, $dst, tmp\n\t# convert D to B vector" %}
  ins_encode %{
    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);
    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// ------------------------------ Vector extract ---------------------------------

instruct extractB(iRegINoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0);
  match(Set dst (ExtractB src idx));
  effect(TEMP pTmp, KILL cr);
  ins_cost(2 * SVE_COST);
  format %{ "movzw rscratch1, $idx\n\t"
            "sve_whilele $pTmp, B, zr, rscratch1\n\t"
            "sve_lastb $dst, B, $pTmp, $src\n\t"
            "sbfmw $dst, $dst, 0U, 7U\t# extract from vector(B)" %}
  ins_encode %{
    __ movzw(rscratch1, (int)($idx$$constant));
    __ sve_whilele(as_PRegister($pTmp$$reg), __ B, zr, rscratch1);
    __ sve_lastb(as_Register($dst$$reg), __ B, as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));
    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 7U);
  %}
  ins_pipe(pipe_slow);
%}

instruct extractS(iRegINoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0);
  match(Set dst (ExtractS src idx));
  effect(TEMP pTmp, KILL cr);
  ins_cost(2 * SVE_COST);
  format %{ "movzw rscratch1, $idx\n\t"
            "sve_whilele $pTmp, H, zr, rscratch1\n\t"
            "sve_lastb $dst, H, $pTmp, $src\n\t"
            "sbfmw $dst, $dst, 0U, 15U\t# extract from vector(S)" %}
  ins_encode %{
    __ movzw(rscratch1, (int)($idx$$constant));
    __ sve_whilele(as_PRegister($pTmp$$reg), __ H, zr, rscratch1);
    __ sve_lastb(as_Register($dst$$reg), __ H, as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));
    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 15U);
  %}
  ins_pipe(pipe_slow);
%}


instruct extractI(iRegINoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0);
  match(Set dst (ExtractI src idx));
  effect(TEMP pTmp, KILL cr);
  ins_cost(2 * SVE_COST);
  format %{ "movzw rscratch1, $idx\n\t"
            "sve_whilele $pTmp, S, zr, rscratch1\n\t"
            "sve_lastb $dst, S, $pTmp, $src\t# extract from vector(I)" %}
  ins_encode %{
    __ movzw(rscratch1, (int)($idx$$constant));
    __ sve_whilele(as_PRegister($pTmp$$reg), __ S, zr, rscratch1);
    __ sve_lastb(as_Register($dst$$reg), __ S, as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct extractL(iRegLNoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0);
  match(Set dst (ExtractL src idx));
  effect(TEMP pTmp, KILL cr);
  ins_cost(2 * SVE_COST);
  format %{ "movzw rscratch1, $idx\n\t"
            "sve_whilele $pTmp, D, zr, rscratch1\n\t"
            "sve_lastb $dst, D, $pTmp, $src\t# extract from vector(L)" %}
  ins_encode %{
    __ movzw(rscratch1, (int)($idx$$constant));
    __ sve_whilele(as_PRegister($pTmp$$reg), __ D, zr, rscratch1);
    __ sve_lastb(as_Register($dst$$reg), __ D, as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct extractF(vRegF dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0);
  match(Set dst (ExtractF src idx));
  effect(TEMP pTmp, KILL cr);
  ins_cost(2 * SVE_COST);
  format %{ "movzw rscratch1, $idx\n\t"
            "sve_whilele $pTmp, S, zr, rscratch1\n\t"
            "sve_lastb $dst, S, $pTmp, $src\t# extract from vector(F)" %}
  ins_encode %{
    __ movzw(rscratch1, (int)($idx$$constant));
    __ sve_whilele(as_PRegister($pTmp$$reg), __ S, zr, rscratch1);
    __ sve_lastb(as_FloatRegister($dst$$reg), __ S, as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct extractD(vRegD dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0);
  match(Set dst (ExtractD src idx));
  effect(TEMP pTmp, KILL cr);
  ins_cost(2 * SVE_COST);
  format %{ "movzw rscratch1, $idx\n\t"
            "sve_whilele $pTmp, D, zr, rscratch1\n\t"
            "sve_lastb $dst, D, $pTmp, $src\t# extract from vector(D)" %}
  ins_encode %{
    __ movzw(rscratch1, (int)($idx$$constant));
    __ sve_whilele(as_PRegister($pTmp$$reg), __ D, zr, rscratch1);
    __ sve_lastb(as_FloatRegister($dst$$reg), __ D, as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// ------------------------------- VectorTest ----------------------------------

instruct vtest_alltrue(iRegINoSp dst, vReg src1, vReg src2, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&
            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);
  match(Set dst (VectorTest src1 src2));
  effect(TEMP pTmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_cmpeq $pTmp, $src1, 0\n\t"
            "csetw $dst, EQ\t# VectorTest (sve) - alltrue" %}
  ins_encode %{
    // "src2" is not used for sve.
    BasicType bt = vector_element_basic_type(this, $src1);
    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,
                 as_FloatRegister($src1$$reg), 0);
    __ csetw(as_Register($dst$$reg), Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct vtest_anytrue(iRegINoSp dst, vReg src1, vReg src2, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&
            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);
  match(Set dst (VectorTest src1 src2));
  effect(TEMP pTmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "sve_cmpeq $pTmp, $src1, -1\n\t"
            "csetw $dst, NE\t# VectorTest (sve) - anytrue" %}
  ins_encode %{
    // "src2" is not used for sve.
    BasicType bt = vector_element_basic_type(this, $src1);
    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,
                 as_FloatRegister($src1$$reg), -1);
    __ csetw(as_Register($dst$$reg), Assembler::NE);
  %}
  ins_pipe(pipe_slow);
%}

instruct vtest_alltrue_partial(iRegINoSp dst, vReg src1, vReg src2, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&
            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::overflow);
  match(Set dst (VectorTest src1 src2));
  effect(TEMP pTmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "vtest_alltrue_partial $dst, $src1, $src2\t# VectorTest partial (sve) - alltrue" %}
  ins_encode %{
    // "src2" is not used for sve.
    BasicType bt = vector_element_basic_type(this, $src1);
    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);
    __ mov(rscratch1, vector_length(this, $src1));
    __ sve_whilelo(as_PRegister($pTmp$$reg), size, zr, rscratch1);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, as_PRegister($pTmp$$reg),
                 as_FloatRegister($src1$$reg), 0);
    __ csetw(as_Register($dst$$reg), Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct vtest_anytrue_partial(iRegINoSp dst, vReg src1, vReg src2, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize &&
            static_cast<const VectorTestNode*>(n)->get_predicate() == BoolTest::ne);
  match(Set dst (VectorTest src1 src2));
  effect(TEMP pTmp, KILL cr);
  ins_cost(SVE_COST);
  format %{ "vtest_anytrue_partial $dst, $src1, $src2\t# VectorTest partial (sve) - anytrue" %}
  ins_encode %{
    // "src2" is not used for sve.
    BasicType bt = vector_element_basic_type(this, $src1);
    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);
    __ mov(rscratch1, vector_length(this, $src1));
    __ sve_whilelo(as_PRegister($pTmp$$reg), size, zr, rscratch1);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, as_PRegister($pTmp$$reg),
                 as_FloatRegister($src1$$reg), -1);
    __ csetw(as_Register($dst$$reg), Assembler::NE);
  %}
  ins_pipe(pipe_slow);
%}

// ------------------------------ Vector insert ---------------------------------

instruct insertB_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);
  ins_cost(4 * SVE_COST);
  format %{ "sve_index $dst, B, -16, 1\n\t"
            "sve_cmpeq $pTmp, $dst, ($idx-#16) // shift from [0, 31] to [-16, 15]\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (B)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($dst$$reg), __ B, -16, 1);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ B, ptrue,
                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ B,
               as_PRegister($pTmp$$reg), as_Register($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct insertS_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);
  ins_cost(4 * SVE_COST);
  format %{ "sve_index $dst, H, -16, 1\n\t"
            "sve_cmpeq $pTmp, $dst, ($idx-#16) // shift from [0, 31] to [-16, 15]\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (S)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($dst$$reg), __ H, -16, 1);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ H, ptrue,
                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ H,
               as_PRegister($pTmp$$reg), as_Register($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_INT);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);
  ins_cost(4 * SVE_COST);
  format %{ "sve_index $dst, S, -16, 1\n\t"
            "sve_cmpeq $pTmp, $dst, ($idx-#16) // shift from [0, 31] to [-16, 15]\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (I)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,
                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,
               as_PRegister($pTmp$$reg), as_Register($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);
  ins_cost(4 * SVE_COST);
  format %{ "sve_index $dst, S, -16, 1\n\t"
            "sve_cmpeq $pTmp, $dst, ($idx-#16) // shift from [0, 31] to [-16, 15]\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (F)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,
                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,
               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct insertL(vReg dst, vReg src, iRegL val, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);
  ins_cost(4 * SVE_COST);
  format %{ "sve_index $dst, D, -16, 1\n\t"
            "sve_cmpeq $pTmp, $dst, ($idx-#16) // shift from [0, 31] to [-16, 15]\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (L)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,
                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,
               as_PRegister($pTmp$$reg), as_Register($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);
  ins_cost(4 * SVE_COST);
  format %{ "sve_index $dst, D, -16, 1\n\t"
            "sve_cmpeq $pTmp, $dst, ($idx-#16) // shift from [0, 31] to [-16, 15]\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (D)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,
                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,
               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}


instruct insertB(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);
  ins_cost(5 * SVE_COST);
  format %{ "sve_index $tmp1, B, 0, 1\n\t"
            "sve_dup $dst, B, $idx\n\t"
            "sve_cmpeq $pTmp, $tmp1, $dst\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (B)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);
    __ sve_dup(as_FloatRegister($dst$$reg), __ B, (int)($idx$$constant));
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ B, ptrue,
                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ B,
               as_PRegister($pTmp$$reg), as_Register($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct insertS(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);
  ins_cost(5 * SVE_COST);
  format %{ "sve_index $tmp1, H, 0, 1\n\t"
            "sve_dup $dst, H, $idx\n\t"
            "sve_cmpeq $pTmp, $tmp1, $dst\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (S)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($tmp1$$reg), __ H, 0, 1);
    __ sve_dup(as_FloatRegister($dst$$reg), __ H, (int)($idx$$constant));
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ H, ptrue,
                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ H,
               as_PRegister($pTmp$$reg), as_Register($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_INT);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);
  ins_cost(5 * SVE_COST);
  format %{ "sve_index $tmp1, S, 0, 1\n\t"
            "sve_dup $dst, S, $idx\n\t"
            "sve_cmpeq $pTmp, $tmp1, $dst\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (I)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);
    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,
                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,
               as_PRegister($pTmp$$reg), as_Register($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)
%{
  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
  match(Set dst (VectorInsert (Binary src val) idx));
  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);
  ins_cost(5 * SVE_COST);
  format %{ "sve_index $tmp1, S, 0, 1\n\t"
            "sve_dup $dst, S, $idx\n\t"
            "sve_cmpeq $pTmp, $tmp1, $dst\n\t"
            "sve_orr $dst, $src, $src\n\t"
            "sve_cpy $dst, $pTmp, $val\t# insert into vector (F)" %}
  ins_encode %{
    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);
    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));
    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,
                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));
    __ sve_orr(as_FloatRegister($dst$$reg),
               as_FloatRegister($src$$reg),
               as_FloatRegister($src$$reg));
    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,
               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// ------------------------------ Vector shuffle -------------------------------
instruct loadshuffleB(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorLoadShuffle src));
  ins_cost(SVE_COST);
  format %{ "sve_orr $dst, $src, $src\t# vector load shuffle (B)" %}
  ins_encode %{
    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {
      __ sve_orr(as_FloatRegister($dst$$reg),
                 as_FloatRegister($src$$reg),
                 as_FloatRegister($src$$reg));
    }
  %}
  ins_pipe(pipe_slow);
%}

instruct loadshuffleS(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorLoadShuffle src));
  ins_cost(SVE_COST);
  format %{ "sve_uunpklo $dst, $src\t# vector load shuffle (B to H)" %}
  ins_encode %{
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct loadshuffleI(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));
  match(Set dst (VectorLoadShuffle src));
  ins_cost(2 * SVE_COST);
  format %{ "sve_uunpklo $dst, $src\n\t"
            "sve_uunpklo $dst, $dst\t# vector load shuffle (B to S)" %}
  ins_encode %{
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct loadshuffleL(vReg dst, vReg src)
%{
  predicate(UseSVE > 0 &&
           (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));
  match(Set dst (VectorLoadShuffle src));
  ins_cost(3 * SVE_COST);
  format %{ "sve_uunpklo $dst, $src\n\t"
            "sve_uunpklo $dst, $dst\n\t"
            "sve_uunpklo $dst, $dst\t# vector load shuffle (B to D)" %}
  ins_encode %{
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));
    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// ------------------------------ Vector rearrange -------------------------------

instruct rearrangeB(vReg dst, vReg src, vReg shuffle)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);
  match(Set dst (VectorRearrange src shuffle));
  ins_cost(SVE_COST);
  format %{ "sve_tbl $dst, B, $src, $shuffle\t# vector rearrange (B)" %}
  ins_encode %{
    __ sve_tbl(as_FloatRegister($dst$$reg), __ B,
               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct rearrangeS(vReg dst, vReg src, vReg shuffle)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);
  match(Set dst (VectorRearrange src shuffle));
  ins_cost(SVE_COST);
  format %{ "sve_tbl $dst, H, $src, $shuffle\t# vector rearrange (S)" %}
  ins_encode %{
    __ sve_tbl(as_FloatRegister($dst$$reg), __ H,
               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct rearrangeI(vReg dst, vReg src, vReg shuffle)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_INT);
  match(Set dst (VectorRearrange src shuffle));
  ins_cost(SVE_COST);
  format %{ "sve_tbl $dst, S, $src, $shuffle\t# vector rearrange (I)" %}
  ins_encode %{
    __ sve_tbl(as_FloatRegister($dst$$reg), __ S,
               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct rearrangeF(vReg dst, vReg src, vReg shuffle)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
  match(Set dst (VectorRearrange src shuffle));
  ins_cost(SVE_COST);
  format %{ "sve_tbl $dst, S, $src, $shuffle\t# vector rearrange (F)" %}
  ins_encode %{
    __ sve_tbl(as_FloatRegister($dst$$reg), __ S,
               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct rearrangeL(vReg dst, vReg src, vReg shuffle)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);
  match(Set dst (VectorRearrange src shuffle));
  ins_cost(SVE_COST);
  format %{ "sve_tbl $dst, D, $src, $shuffle\t# vector rearrange (L)" %}
  ins_encode %{
    __ sve_tbl(as_FloatRegister($dst$$reg), __ D,
               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct rearrangeD(vReg dst, vReg src, vReg shuffle)
%{
  predicate(UseSVE > 0 &&
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
  match(Set dst (VectorRearrange src shuffle));
  ins_cost(SVE_COST);
  format %{ "sve_tbl $dst, D, $src, $shuffle\t# vector rearrange (D)" %}
  ins_encode %{
    __ sve_tbl(as_FloatRegister($dst$$reg), __ D,
               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// ------------------------------ Vector Load Gather ---------------------------------
instruct gatherI(vReg dst, vmemA mem, vReg idx) %{
  predicate(UseSVE > 0 &&
           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||
            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));
  match(Set dst (LoadVectorGather mem idx));
  ins_cost(SVE_COST);
  format %{ "load_vector_gather $dst, $mem, $idx\t# vector load gather (I/F)" %}
  ins_encode %{
    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), ptrue, as_Register($mem$$base), as_FloatRegister($idx$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct gatherL(vReg dst, vmemA mem, vReg idx) %{
  predicate(UseSVE > 0 &&
           (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||
            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));
  match(Set dst (LoadVectorGather mem idx));
  ins_cost(2 * SVE_COST);
  format %{ "sve_uunpklo $idx, $idx\n\t"
            "load_vector_gather $dst, $mem, $idx\t# vector load gather (L/D)" %}
  ins_encode %{
    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));
    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue, as_Register($mem$$base), as_FloatRegister($idx$$reg));
  %}
  ins_pipe(pipe_slow);
%}

// ------------------------------ Vector Store Scatter -------------------------------
instruct scatterI(vmemA mem, vReg src, vReg idx) %{
  predicate(UseSVE > 0 &&
           (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||
            n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));
  match(Set mem (StoreVectorScatter mem (Binary src idx)));
  ins_cost(SVE_COST);
  format %{ "store_vector_scatter $mem, $idx, $src\t# vector store scatter (I/F)" %}
  ins_encode %{
    __ sve_st1w_scatter(as_FloatRegister($src$$reg), ptrue, as_Register($mem$$base), as_FloatRegister($idx$$reg));
  %}
  ins_pipe(pipe_slow);
%}

instruct scatterL(vmemA mem, vReg src, vReg idx) %{
  predicate(UseSVE > 0 &&
           (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||
            n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));
  match(Set mem (StoreVectorScatter mem (Binary src idx)));
  ins_cost(2 * SVE_COST);
  format %{ "sve_uunpklo $idx, $idx\n\t"
            "store_vector_scatter $mem, $idx, $src\t# vector store scatter (L/D)" %}
  ins_encode %{
    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));
    __ sve_st1d_scatter(as_FloatRegister($src$$reg), ptrue, as_Register($mem$$base), as_FloatRegister($idx$$reg));
  %}
  ins_pipe(pipe_slow);
%}
